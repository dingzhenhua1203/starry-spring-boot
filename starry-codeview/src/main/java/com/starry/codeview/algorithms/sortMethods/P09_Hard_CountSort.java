package com.starry.codeview.algorithms.sortMethods;
/**
 * 计数排序
 * 计数排序是一个非基于比较的排序算法，元素从未排序状态变为已排序状态的过程，是由额外空间的辅助和元素本身的值决定的。
 * 它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。
 * 当然这是一种牺牲空间换取时间的做法，而且当Ο(k)>Ο(nlogn)的时候其效率反而不如基于比较的排序，因为基于比较的排序的时间复杂度在理论上的下限是Ο(nlogn)。
 *
 * 算法思路
 * 计数排序对输入的数据有附加的限制条件：
 *
 * 1、输入的线性表的元素属于有限偏序集 S；
 *
 * 2、设输入的线性表的长度为 n，|S|=k（表示集合 S 中元素的总数目为 k），则 k=O(n)。
 *
 * 在这两个条件下，计数排序的复杂性为O(n)。
 *
 * 计数排序的基本思想是对于给定的输入序列中的每一个元素 x，确定该序列中值小于 x 的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将 x 直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有 17 个元素的值小于 x 的值，则 x 可以直接存放在输出序列的第 18 个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。
 *
 * 算法过程
 * 根据待排序集合中最大元素和最小元素的差值范围，申请额外空间；
 * 遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内；
 * 对额外空间内数据进行计算，得出每一个元素的正确位置；
 * 将待排序集合每一个元素移动到计算得出的正确位置上。
 */
public class P09_Hard_CountSort
{
}
